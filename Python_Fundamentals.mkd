# Python Fundamentals #

Python is a popular open source programming language that is commonly used for scripting, web programming, data analysis, and hobbyist projects. Python is object oriented, strongly typed, dynamically typed, and uses duck typing. Python is flexible, and can be interpreted or compiled. Python uses white-space to limit syntax. Multiple Python runtimes exist, written to many platforms and in different languages.

## Getting Started ##

Python is probably available on your development platform of choice, look up how to install it on your system if you don't know how.

For quick scripting you can use a REPL by running Python in your command window. Note that you may have to specify `python`, `python2`, or `python3` depending on your install. This course will use Python 3, though remember you may come across Python 2 code in the wild that can't run on Python 3. The REPL lets you type in code and can immediately evaluate what you write. *Protip: you can use an underscore to refer to the value returned by the last evaluation you ran, but only in the REPL*.

Remember to use the `print(some_string)` function to print to the shell, python 2 uses `print some_string`. Remember to use 4 spaces for your indentation as convention. Avoid using tabs, and do not mix tabs and spaces. If you must break convention, do it consistently. Breaking convention for readability will probably be begrudgingly accepted.

Python has a series of documentation called PEPs, Python Enhancement proposals, and is similar to RFCs. PEP-20 is called "The Zen of Python", and tries to capture the spirit of using it. Check it out by running `import this` at a REPL.

### Syntax basics ###

`import` brings in module libraries. Object methods are accessed using `.` like C-style languages. You can import module functions more selectively using `from some_module import your_function_choice` and `your_function_choice` is accessible in your namespace. You can give aliases to imported code using `as` after the import, but this is not heavily encouraged, remember code clarity.

#### Value Types ####

Python numbers grow as the value grows, can be abitrarily large. Python types can be grouped into "Scalar" types, which are not collections. Scalar types include `int`, `float`, `None`, and `bool`.

`int` values hold integer values. You can specify binary, octal, and hex values using `0b`, `0o`, and `0x` before your value. To convert a value of a different type into an int, just pass it into `int()`. When rounding, the value is floored. You can use scientific notation for int values.

Python has values `nan` for a value that can not be interpreted as a number, and `inf`, and `-inf` for infinite values.

`float()` can convert other values into floats.

`None` is Python's `null` value. `True` and `False` are `bool` values. You can pass in values to `bool()` to generate a `True` or `False` value. `0` and `0.0` are falsy values, positive and negative numbers are truthy. Empty arrays and empty strings are falsy. Arrays with values and non-empty strings are truthy. The string "False" is truthy.

#### Relational Operators ####

Python uses

```
==
!=
<
>
<=
>=
```

#### Conditionals ####

```
if True:
    print("Hello World!")

if bool("More?"):
    print("Yes please")

if "Really more":
    print("YES")

print("Are sure sure?")
anser = input()
if answer == "Really more":
    print("OK THEN")
elif anwser == "Nah not really":
    print("move along")
else:
    print("WHAAT?")
```

#### Looping ####

Python has `while` loops and `for` loops

```
c = 5
# the below can be written like
# while c:
# but remember "Explict is better than implict"
while c != 0:
    print(c)
    c -= 1

```

Python does not have a "do-while" loop in the language. Instead, use `while True:` then use the `break` keyword to get out of the loop early as you can. This is a language idiom.

## Strings and Collections ##

Python has `str`, `bytes`, `list`, and `dict` types.

`str` are immutable sequences of Unicode "codepoints", and are Python's strings. `str` literals can be delimited with single or double quotes.

Literal strings can be concatenated with a space between the two values. Multi-line strings are delimited with 3 quotes/double quotes, or you can use `\n`. `\n` is Universally supposed, meaning it will use your OS's conventions for newlines, like carrage return, newline on Windows.

In the case of strings with backslashes, if you don't want to escape every backslash, you can use "raw strings", where you lead the string like `r'Hello!'`

You can use `str()` to convert values to strings. `str` is considered a sequence type, so you can index it like arrays in other languages. Python has no character type, a character is just a `str` of `len(mystring) == 1`

Strings are Unicode, and you can refer to characters using character codes and Python will resolve them for you on print.

`byte` are immutable values that written as `b'some data'`. You must know the encoding of a `byte` or `str` to decode or encode.

`list` are mutable sequences of objects and are literally written as `[1, 2, 3, "four", some_var]`. `list` has many methods you can use to manipulate them. You can create lists from other collections using `list("my character list")`. 

If you have a long literal list, you can break up the declaration on separate lines as long as they end with a comma. You can also have a "trailing comma" at the last element in the list, and this will not be a syntax error.

`dict` is Python's dictionary or associative array type. `dict` literals are written like `{k1: v1, k2: v2}`. To add a new key and value to a `dict`, use something like `my_dictionary['best_key'] = "best_value"`, and it'll be added.

### `for` loops ###

Python's `for` loops are like "for each" loops, like

```
for member in iterable:
    print(member)

```

If you want a loop that's closer to a C-style for loop, you can use a "range", like `for x in [0..10]:`

### `with` ###

`with` is like C#'s `using`, for manipulating resources that maintain an open state. You use it like

```
with urlopen(my_url) as response_data:
    for line in response_data:
        print(line)

```


## Modularity ##

Modules are how you create smaller, reusable code files in larger Python programs.

To use modules you've written, you use `import firstscript` if the file you made is called "firstscript.py" and it's in your local directory. When you import a module, its code is executed immediately, so you may want block your code into smaller sized functions.

You define functions in blocks like

```
def my_first_function():
    print("hello world!")

def my_second_function():
    return "hello world!"

def my_empty function():
    return

what_am_i = my_empty_function()
if what_am_i is None:
    print("I am nothing!")
else:
    print("I am significant")
```

### Double Underscores ###

Python uses some special syntax, wrapping some attributes in double underscores. For example, `__name__` will resolve to the name of this module or "__main__" if it's being run as a script.

You can use this to your advantage if you want to be able to run your code as both a module in Python or from a shell. You check

```
if __name__ == "__main__":
    # python you want to run if called by
    # name in the shell

```

It is conventional to write your code in such a way that can be used when called directly from the command line, or imported as a module.

If you'd like to import a handful of useful functions from a module, you can use `from words import (fetch_words, print_words)` or you can even (while testing) use `from words import *`, though is isn't recommended for prod code.

It's recommended to create a `main()` function if you intend your code to be run as a script, and to parameterize your functions as much as you can to facilitate reuse.

It's convention to space your function definitions with two newlines.

### Doc Strings ###

Python has a special syntax for creating documentation, called doc strings. Doc strings are triple double-quotes the first line after the `def` line for a function. There are different conventions for formatting doc strings, it may vary from project to project. Google has a convention available, that allows the doc string to be parsed for a number of utilities.

Docstings can be looked at using `help()`, check this out to see about calling it from the shell.

### Comments ###

If you need to use comments, use `#`. This will comment out the rest of the line after the `#`. It may be useful to put in UNIX shebangs in your python files so you can just call the filename, and it runs as a command under the right version of Python.

Windows has a utility called PyLauncher that will associate UNIX shebangs to the right version of Python on Windows, without changing the shebang. Check it out.


## Objects ##

Python is an Object Oriented language, and has language features that enable object oriented style programming.

Python has a build-in `id()` function that may be useful for testing and debugging some code that will create an id for the object to it, the idea being that if two different objects, but they point to the same value, the ids will be the same. If you really want two objects pointing to two separate values that are equal to each other, you basically need to clone the value.

If you pass in a mutable object into a function, and modify it, the changes will persist when the function returns. However, if you pass in an object, assign it to a new object in the function, it will revert back to the prior assigned value on return. This is pass by reference.

### Function Arguments ###

You can specify optional arguments to functions by specifying default values in the definition.

```
# Optional parameters must come after
# required parameters
def banner(message, border='-'):
    line = border * len(message)
    print(line)
    print(message)
    print(line)

banner("Hey welcome!")
banner("What's up", "*")
```

Python lets you change order of parameters by using the name of the parameter equal to a value. Otherwise, Python resolves parameters by position.

```
banner(border="=", message=some_message)
```

Be wary when you used a derived value as a parameter default value, as this value is evaluated when imported and only evaluated once.

Also be wary of using mutable collections as default values for functions. Python will close over this collection and if you modify its contents, the changes will persist over function calls. Therefore, it's a best practice to always use immutable values as defaults. In the case of collections, like a list, try setting its default value to `None` like so

```
# menu is intended to be a list
def add_spam(menu=None):
    if menu is None:
        menu = []
    menu.append('spam')
    return menu

```

### Python's type system ###

Python is dynamically typed (meaning you don't have to declare what type a variable is) and is strongly typed (meaning there are no implicit type conversions) However, values do have an evaluated `bool` value in the case of conditionals and loops that you don't necessarily have to wrap in a `bool()`

### Variable scope ###

Python has four levels of scoping

Local | in the current function
Enclosing | any and all enclosing functions (like closures?)
Global | Defined at top level, accessible everywhere
Builtin | come in from the Python runtime

Suppose though you have a module that are a collection of functions that have some value you want to close over like if you were writing JavaScript. If you want to access/change that value in your functions, you must declare you are referring to a global variable using `global` followed by the name of that variable.

### Everything is an object ###

Including modules, functions, builtin values, and "basic" values. To find the type of a value, you can pass it into `type()`. To find the attributes of an object, you can pass it into `dir()`.

`__name__` in the case of functions or modules will return the name of the function or the module. `__doc__` will return the docstring for that object if available.
